Aæ˜Ÿç®—æ³•Javaå®ç°

ä¸€ã€é€‚ç”¨åœºæ™¯
åœ¨ä¸€å¼ åœ°å›¾ä¸­ï¼Œç»˜åˆ¶ä»èµ·ç‚¹ç§»åŠ¨åˆ°ç»ˆç‚¹çš„æœ€ä¼˜è·¯å¾„ï¼Œåœ°å›¾ä¸­ä¼šæœ‰éšœç¢ç‰©ï¼Œå¿…é¡»ç»•å¼€éšœç¢ç‰©ã€‚

äºŒã€ç®—æ³•æ€è·¯
1. å›æº¯æ³•å¾—åˆ°è·¯å¾„
   (å¦‚æœæœ‰è·¯å¾„)é‡‡ç”¨â€œç»“ç‚¹ä¸ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹â€çš„å…³ç³»ä»æœ€ç»ˆç»“ç‚¹å›æº¯åˆ°èµ·ç‚¹ï¼Œå¾—åˆ°è·¯å¾„ã€‚

2. è·¯å¾„ä»£ä»·çš„ä¼°ç®—ï¼šF = G+H
   Aæ˜Ÿç®—æ³•çš„ä»£ä»·è®¡ç®—ä½¿ç”¨äº†è¢«ç§°ä½œæ˜¯å¯å‘å¼çš„ä»£ä»·å‡½æ•°ã€‚ å…ˆè¯´æ˜ä¸€ä¸‹å„ç¬¦å·æ„ä¹‰ï¼šGè¡¨ç¤ºçš„æ˜¯ä»èµ·ç‚¹åˆ°å½“å‰ç»“ç‚¹çš„å®é™…è·¯å¾„ä»£ä»·(ä¸ºå•¥å«å®é™…ï¼Ÿå°±æ˜¯å·²ç»èµ°è¿‡äº†ï¼Œè¾¹èµ°è¾¹å°†ä»£ä»·è®¡ç®—å¥½äº†)ï¼›Hè¡¨ç¤ºå½“å‰ç»“ç‚¹åˆ°è¾¾æœ€ç»ˆç»“ç‚¹çš„ä¼°è®¡ä»£ä»·(ä¸ºå•¥å«ä¼°è®¡ï¼Ÿå°±æ˜¯è¿˜æ²¡èµ°è¿‡ï¼Œä¸çŸ¥é“å‰é¢æœ‰æ²¡éšœç¢ã€è·¯é€šä¸é€šï¼Œæ‰€ä»¥åªèƒ½ç”¨ä¼°è®¡)ï¼›Fè¡¨ç¤ºå½“å‰ç»“ç‚¹æ‰€åœ¨è·¯å¾„ä»èµ·ç‚¹åˆ°æœ€ç»ˆç‚¹é¢„ä¼°çš„æ€»è·¯å¾„ä»£ä»·ã€‚

Gçš„è®¡ç®—æ–¹å¼ï¼šè®¡ç®—æ–¹å¼æœ‰æŒºå¤šç§çš„ï¼Œè¿™é‡Œæˆ‘ä»¬å°±ç”¨è¿™ç§å§ï¼Œå‡è®¾æ¯ä¸ªç»“ç‚¹ä»£è¡¨ä¸€ä¸ªæ­£æ–¹å½¢ï¼Œæ¨ªç«–ç§»åŠ¨è·ç¦»ï¼šæ–œç§»åŠ¨è·ç¦»=1ï¼š1.4ï¼ˆæ ¹å·2ï¼‰ï¼Œæˆ‘ä»¬å–ä¸ªæ•´æ•°10å’Œ14å§ï¼Œä¹Ÿå°±æ˜¯è¯´å½“å‰ç»“ç‚¹Gå€¼=çˆ¶èŠ‚ç‚¹çš„G+ï¼ˆ10æˆ–14ï¼‰ã€‚

Hçš„è®¡ç®—æ–¹å¼ï¼šä¼°ä»·è®¡ç®—ä¹Ÿæœ‰å¾ˆå¤šç§æ–¹å¼ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨â€œæ›¼å“ˆé¡¿â€æ³•ï¼ŒH=(|å½“å‰ç»“ç‚¹xå€¼-æœ€ç»ˆç»“ç‚¹xå€¼|+|å½“å‰ç»“ç‚¹yå€¼-æœ€ç»ˆç»“ç‚¹yå€¼|) * æ¨ªç«–ç§»åŠ¨ä»£ä»·å€¼ï¼ˆ"||"è¡¨ç¤ºç»å¯¹å€¼ï¼‰ã€‚

å¦‚ä¸‹å›¾ï¼ˆå›¾ä¸æ˜¯è‡ªå·±åšçš„ï¼Œä»ç½‘ä¸Šå€Ÿæ¥çš„ï¼Œè‡ªå·±ç”»çš„è¯~...æƒ¨ä¸å¿ç¹ï¼ï¼‰



3. è¾…åŠ©è¡¨ï¼šOpenã€Closeåˆ—è¡¨
   åœ¨Aæ˜Ÿç®—æ³•ä¸­ï¼Œéœ€è¦ä½¿ç”¨ä¸¤ä¸ªè¾…åŠ©è¡¨æ¥è®°å½•ç»“ç‚¹ã€‚ ä¸€ä¸ªç”¨äºè®°å½•å¯è¢«è®¿é—®çš„ç»“ç‚¹ï¼Œæˆä¸ºOpenè¡¨ï¼›ä¸€ä¸ªæ˜¯è®°å½•å·²è®¿é—®è¿‡çš„ç»“ç‚¹ï¼Œç§°ä¸ºCloseè¡¨ã€‚ è¿™ä¸¤ä¸ªè¡¨å†³å®šäº†ç®—æ³•çš„ç»“æŸï¼šæ¡ä»¶æ˜¯æœ€ç»ˆç»“ç‚¹åœ¨Closeè¡¨ä¸­(æ‰¾åˆ°è·¯å¾„)æˆ–Openè¡¨ä¸ºç©º(æ‰¾ä¸åˆ°äº†è·¯å¾„)ã€‚

4. ç§»åŠ¨ç»“ç‚¹ã€ç›¸é‚»ç»“ç‚¹çš„å¤„ç†
   ä¸Šé¢çš„ç†è§£çš„è¯ï¼Œç°åœ¨å°±æ¥ç§»åŠ¨å½“å‰çš„èŠ‚ç‚¹ï¼Œå¯»æ‰¾è·¯å¾„ã€‚

æ¯æ¬¡ä»Openè¡¨ä¸­å–å‡ºFå€¼æœ€å°çš„ç»“ç‚¹å‡ºæ¥ï¼ˆè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—æ¥å¤„ç†æ¯”è¾ƒå¥½ï¼‰ï¼Œä½œä¸ºå½“å‰ç»“ç‚¹ï¼›ç„¶åå°†å½“å‰ç»“ç‚¹çš„æ‰€æœ‰é‚»ç»“ç‚¹æŒ‰ç…§é‚»ç»“ç‚¹è§„åˆ™åŠ å…¥åˆ°Openè¡¨ä¸­ï¼›æœ€åå°†å½“å‰ç»“ç‚¹æ”¾å…¥Closeè¡¨ä¸­ï¼Œè¿™é‡Œå°±æ˜¯æ¯æ¬¡å¾ªç¯çš„æ‰§è¡Œå†…å®¹ã€‚

é‚»ç»“ç‚¹è§„åˆ™ï¼š (1) å½“é‚»ç»“ç‚¹ä¸åœ¨åœ°å›¾ä¸­ï¼Œä¸åŠ å…¥Openè¡¨ï¼› (2) å½“é‚»ç»“ç‚¹æ˜¯éšœç¢ç‰©ï¼Œä¸åŠ å…¥Openè¡¨ï¼› (3) å½“é‚»ç»“ç‚¹åœ¨Closeè¡¨ä¸­ï¼Œä¸åŠ å…¥Openè¡¨ï¼› (4) å½“é‚»ç»“ç‚¹ä¸åœ¨Openä¸­ï¼ŒåŠ å…¥Openè¡¨ï¼Œè®¾è¯¥é‚»ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºå½“å‰ç»“ç‚¹ï¼› (5) **å½“é‚»ç»“ç‚¹åœ¨Openè¡¨ä¸­ï¼Œæˆ‘ä»¬éœ€è¦åšä¸ªæ¯”è¾ƒ:å¦‚æœé‚»ç»“ç‚¹çš„Gå€¼>å½“å‰ç»“ç‚¹çš„Gå€¼+å½“å‰ç»“ç‚¹åˆ°è¿™ä¸ªé‚»ç»“ç‚¹çš„ä»£ä»·ï¼Œé‚£ä¹ˆä¿®æ”¹è¯¥é‚»ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºå½“å‰çš„ç»“ç‚¹(å› ä¸ºåœ¨Openè¡¨ä¸­çš„ç»“ç‚¹é™¤äº†èµ·ç‚¹ï¼Œéƒ½ä¼šæœ‰çˆ¶èŠ‚ç‚¹)ï¼Œä¿®æ”¹Gå€¼=å½“å‰ç»“ç‚¹çš„Gå€¼+å½“å‰ç»“ç‚¹åˆ°è¿™ä¸ªé‚»ç»“ç‚¹çš„ä»£ä»· **

è“è‰²æ¡†æ¡†è¡¨ç¤ºåœ¨Closeè¡¨ä¸­ï¼Œç»¿è‰²çš„æ¡†æ¡†è¡¨ç¤ºåœ¨Openè¡¨ä¸­



æœ€åå›æº¯å¾—åˆ°è·¯å¾„



ä¸‰ã€ä»£ç å®ç°(Java)
1. è¾“å…¥
   (1) ä»£è¡¨åœ°å›¾äºŒå€¼äºŒç»´æ•°ç»„(0è¡¨ç¤ºå¯é€šè·¯ï¼Œ1è¡¨ç¤ºè·¯éšœ)

int[][] maps = {
{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }
};
(2) æŒ‰ç…§äºŒç»´æ•°ç»„çš„ç‰¹ç‚¹ï¼Œåæ ‡åŸç‚¹åœ¨å·¦ä¸Šè§’ï¼Œæ‰€ä»¥yæ˜¯é«˜ï¼Œxæ˜¯å®½ï¼Œyå‘ä¸‹é€’å¢ï¼Œxå‘å³é€’å¢ï¼Œæˆ‘ä»¬å°†xå’Œyå°è£…æˆä¸€ä¸ªç±»ï¼Œå¥½ä¼ å‚ï¼Œé‡å†™equalsæ–¹æ³•æ¯”è¾ƒåæ ‡(x,y)æ˜¯ä¸æ˜¯åŒä¸€ä¸ªã€‚

public class Coord
{
public int x;
public int y;

    public Coord(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj == null) return false;
        if (obj instanceof Coord)
        {
            Coord c = (Coord) obj;
            return x == c.x && y == c.y;
        }
        return false;
    }
}
(3) å°è£…è·¯å¾„ç»“ç‚¹ç±»ï¼Œå­—æ®µåŒ…æ‹¬ï¼šåæ ‡ã€Gå€¼ã€Få€¼ã€çˆ¶ç»“ç‚¹ï¼Œå®ç°Comparableæ¥å£ï¼Œæ–¹ä¾¿ä¼˜å…ˆé˜Ÿåˆ—æ’åºã€‚

public class Node implements Comparable<Node>
{

    public Coord coord; // åæ ‡
    public Node parent; // çˆ¶ç»“ç‚¹
    public int G; // Gï¼šæ˜¯ä¸ªå‡†ç¡®çš„å€¼ï¼Œæ˜¯èµ·ç‚¹åˆ°å½“å‰ç»“ç‚¹çš„ä»£ä»·
    public int H; // Hï¼šæ˜¯ä¸ªä¼°å€¼ï¼Œå½“å‰ç»“ç‚¹åˆ°ç›®çš„ç»“ç‚¹çš„ä¼°è®¡ä»£ä»·

    public Node(int x, int y)
    {
        this.coord = new Coord(x, y);
    }

    public Node(Coord coord, Node parent, int g, int h)
    {
        this.coord = coord;
        this.parent = parent;
        G = g;
        H = h;
    }

    @Override
    public int compareTo(Node o)
    {
        if (o == null) return -1;
        if (G + H > o.G + o.H)
            return 1;
        else if (G + H < o.G + o.H) return -1;
        return 0;
    }
}
(4) æœ€åä¸€ä¸ªæ•°æ®ç»“æ„æ˜¯Aæ˜Ÿç®—æ³•è¾“å…¥çš„æ‰€æœ‰æ•°æ®ï¼Œå°è£…åœ¨ä¸€èµ·ï¼Œä¼ å‚æ–¹ä¾¿ã€‚ğŸ˜

public class MapInfo
{
public int[][] maps; // äºŒç»´æ•°ç»„çš„åœ°å›¾
public int width; // åœ°å›¾çš„å®½
public int hight; // åœ°å›¾çš„é«˜
public Node start; // èµ·å§‹ç»“ç‚¹
public Node end; // æœ€ç»ˆç»“ç‚¹

    public MapInfo(int[][] maps, int width, int hight, Node start, Node end)
    {
        this.maps = maps;
        this.width = width;
        this.hight = hight;
        this.start = start;
        this.end = end;
    }
}
2. å¤„ç†
   (1) åœ¨ç®—æ³•é‡Œéœ€è¦å®šä¹‰å‡ ä¸ªå¸¸é‡æ¥ç¡®å®šï¼šäºŒç»´æ•°ç»„ä¸­å“ªä¸ªå€¼è¡¨ç¤ºéšœç¢ç‰©ã€äºŒç»´æ•°ç»„ä¸­ç»˜åˆ¶è·¯å¾„çš„ä»£è¡¨å€¼ã€è®¡ç®—Gå€¼éœ€è¦çš„æ¨ªçºµç§»åŠ¨ä»£ä»·å’Œæ–œç§»åŠ¨ä»£ä»·ã€‚

   public final static int BAR = 1; // éšœç¢å€¼
   public final static int PATH = 2; // è·¯å¾„
   public final static int DIRECT_VALUE = 10; // æ¨ªç«–ç§»åŠ¨ä»£ä»·
   public final static int OBLIQUE_VALUE = 14; // æ–œç§»åŠ¨ä»£ä»·
   (2) å®šä¹‰ä¸¤ä¸ªè¾…åŠ©è¡¨ï¼šOpenè¡¨å’ŒCloseè¡¨ã€‚Openè¡¨çš„ä½¿ç”¨æ˜¯éœ€è¦å–æœ€å°å€¼ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨Javaå·¥å…·åŒ…ä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—PriorityQueueï¼ŒCloseåªæ˜¯ç”¨æ¥ä¿å­˜ç»“ç‚¹ï¼Œæ²¡å…¶ä»–ç‰¹æ®Šç”¨é€”ï¼Œå°±ç”¨ArrayListã€‚

   Queue<Node> openList = new PriorityQueue<Node>(); // ä¼˜å…ˆé˜Ÿåˆ—(å‡åº)
   List<Node> closeList = new ArrayList<Node>();
   (3) å®šä¹‰å‡ ä¸ªå¸ƒå°”åˆ¤æ–­æ–¹æ³•ï¼šæœ€ç»ˆç»“ç‚¹çš„åˆ¤æ–­ã€ç»“ç‚¹èƒ½å¦åŠ å…¥openè¡¨çš„åˆ¤æ–­ã€ç»“ç‚¹æ˜¯å¦åœ¨Closeè¡¨ä¸­çš„åˆ¤æ–­ã€‚

   /**
    * åˆ¤æ–­ç»“ç‚¹æ˜¯å¦æ˜¯æœ€ç»ˆç»“ç‚¹
      */
      private boolean isEndNode(Coord end,Coord coord)
      {
      return coord != null && end.equals(coord);
      }

   /**
    * åˆ¤æ–­ç»“ç‚¹èƒ½å¦æ”¾å…¥Openåˆ—è¡¨
      */
      private boolean canAddNodeToOpen(MapInfo mapInfo,int x, int y)
      {
      // æ˜¯å¦åœ¨åœ°å›¾ä¸­
      if (x < 0 || x >= mapInfo.width || y < 0 || y >= mapInfo.hight) return false;
      // åˆ¤æ–­æ˜¯å¦æ˜¯ä¸å¯é€šè¿‡çš„ç»“ç‚¹
      if (mapInfo.maps[y][x] == BAR) return false;
      // åˆ¤æ–­ç»“ç‚¹æ˜¯å¦å­˜åœ¨closeè¡¨
      if (isCoordInClose(x, y)) return false;

      return true;
      }

   /**
    * åˆ¤æ–­åæ ‡æ˜¯å¦åœ¨closeè¡¨ä¸­
      */
      private boolean isCoordInClose(Coord coord)
      {
      return coord!=null&&isCoordInClose(coord.x, coord.y);
      }

   /**
    * åˆ¤æ–­åæ ‡æ˜¯å¦åœ¨closeè¡¨ä¸­
      */
      private boolean isCoordInClose(int x, int y)
      {
      if (closeList.isEmpty()) return false;
      for (Node node : closeList)
      {
      if (node.coord.x == x && node.coord.y == y)
      {
      return true;
      }
      }
      return false;
      }
      (4) è®¡ç®—Hå€¼ï¼Œâ€œæ›¼å“ˆé¡¿â€ æ³•ï¼Œåæ ‡åˆ†åˆ«å–å·®å€¼ç›¸åŠ 

private int calcH(Coord end,Coord coord)
{
return (Math.abs(end.x - coord.x) + Math.abs(end.y - coord.y)) * DIRECT_VALUE;
}
(5) ä»Openåˆ—è¡¨ä¸­æŸ¥æ‰¾ç»“ç‚¹

private Node findNodeInOpen(Coord coord)
{
if (coord == null || openList.isEmpty()) return null;
for (Node node : openList)
{
if (node.coord.equals(coord))
{
return node;
}
}
return null;
}
(6) æ·»åŠ é‚»ç»“ç‚¹åˆ°Openè¡¨

/**
* æ·»åŠ æ‰€æœ‰é‚»ç»“ç‚¹åˆ°openè¡¨
  */
  private void addNeighborNodeInOpen(MapInfo mapInfo,Node current)
  {
  int x = current.coord.x;
  int y = current.coord.y;
  // å·¦
  addNeighborNodeInOpen(mapInfo,current, x - 1, y, DIRECT_VALUE);
  // ä¸Š
  addNeighborNodeInOpen(mapInfo,current, x, y - 1, DIRECT_VALUE);
  // å³
  addNeighborNodeInOpen(mapInfo,current, x + 1, y, DIRECT_VALUE);
  // ä¸‹
  addNeighborNodeInOpen(mapInfo,current, x, y + 1, DIRECT_VALUE);
  // å·¦ä¸Š
  addNeighborNodeInOpen(mapInfo,current, x - 1, y - 1, OBLIQUE_VALUE);
  // å³ä¸Š
  addNeighborNodeInOpen(mapInfo,current, x + 1, y - 1, OBLIQUE_VALUE);
  // å³ä¸‹
  addNeighborNodeInOpen(mapInfo,current, x + 1, y + 1, OBLIQUE_VALUE);
  // å·¦ä¸‹
  addNeighborNodeInOpen(mapInfo,current, x - 1, y + 1, OBLIQUE_VALUE);
  }

/**
* æ·»åŠ ä¸€ä¸ªé‚»ç»“ç‚¹åˆ°openè¡¨
  */
  private void addNeighborNodeInOpen(MapInfo mapInfo,Node current, int x, int y, int value)
  {
  if (canAddNodeToOpen(mapInfo,x, y))
  {
  Node end=mapInfo.end;
  Coord coord = new Coord(x, y);
  int G = current.G + value; // è®¡ç®—é‚»ç»“ç‚¹çš„Gå€¼
  Node child = findNodeInOpen(coord);
  if (child == null)
  {
  int H=calcH(end.coord,coord); // è®¡ç®—Hå€¼
  if(isEndNode(end.coord,coord))
  {
  child=end;
  child.parent=current;
  child.G=G;
  child.H=H;
  }
  else
  {
  child = new Node(coord, current, G, H);
  }
  openList.add(child);
  }
  else if (child.G > G)
  {
  child.G = G;
  child.parent = current;
  // é‡æ–°è°ƒæ•´å †
  openList.add(child);
  }
  }
  }
  (7) å›æº¯æ³•ç»˜åˆ¶è·¯å¾„

private void drawPath(int[][] maps, Node end)
{
if(end==null||maps==null) return;
System.out.println("æ€»ä»£ä»·ï¼š" + end.G);
while (end != null)
{
Coord c = end.coord;
maps[c.y][c.x] = PATH;
end = end.parent;
}
}
(8) å¼€å§‹ç®—æ³•ï¼Œå¾ªç¯ç§»åŠ¨ç»“ç‚¹å¯»æ‰¾è·¯å¾„ï¼Œè®¾å®šå¾ªç¯ç»“æŸæ¡ä»¶ï¼ŒOpenè¡¨ä¸ºç©ºæˆ–è€…æœ€ç»ˆç»“ç‚¹åœ¨Closeè¡¨

public void start(MapInfo mapInfo)
{
if(mapInfo==null) return;
// clean
openList.clear();
closeList.clear();
// å¼€å§‹æœç´¢
openList.add(mapInfo.start);
moveNodes(mapInfo);
}

/**
* ç§»åŠ¨å½“å‰ç»“ç‚¹
  */
  private void moveNodes(MapInfo mapInfo)
  {
  while (!openList.isEmpty())
  {
  Node current = openList.poll();
  closeList.add(current);
  addNeighborNodeInOpen(mapInfo,current);
  if (isCoordInClose(mapInfo.end.coord))
  {
  drawPath(mapInfo.maps, mapInfo.end);
  break;
  }
  }
  }